\RequirePackage[l2tabu,orthodox]{nag}
\documentclass[10pt,twocolumn,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{tikz}

\usepackage[margin=2cm]{geometry}

\usepackage[
	backend=biber,
	citestyle=numeric-comp
]{biblatex}
\addbibresource{gui.bib}

\usepackage[os=win]{menukeys}

\usepackage[hidelinks]{hyperref}

\author{Markus Himmel}
\title{Windows GUI}

\newcommand{\bs}[1]{\textbf{\sffamily #1}}
\newcommand{\winver}[1]{$^{\text{\hyperref[tbl:abbrev]{\bs{#1}}}}$}
\newcommand{\winsection}[2]{\section{#1\winver{#2}}[#1]}
\newcommand{\winsubsection}[2]{\subsection[#1]{#1\winver{#2}}}

\begin{document}
	\maketitle

	\begin{abstract}
		The Graphical User Interface is one of the most important components
		of a consumer-oriented operating system such as Microsoft Windows. As
		such, its proper functioning is crucial to the operating system's success.

		This report examines the components of the Windows operating system
		that contribute to the graphical user interface, both from an
		application programmer's and a system architect's point of view. The
		APIs presented to application programmers to register GUI applications
		and to draw graphical applications to the screen are reviewed. In addition,
		implementation details of the graphical user interface and window management
		are examined.
	\end{abstract}

	\section{Introduction}
		A \textit{Graphical User Interface} (GUI) is a means of communicating
		with an electronic device such as a personal computer that uses graphical
		icons and other visual indicators to represent application state. In
		contrast, classical command-line interfaces represent program state to
		the user using text-based representations. In addition, when a GUI is
		in use, the user is able to manipulate application elements using graphical
		message, for example by selecting or dragging with a computer mouse.

		An important reason for choosing a graphical user interface for an
		application instead of a text-based one is that in some cases, graphical
		representations of application state give access to more intuitive and
		better metaphors, i.e., appropriate images and icons better represent
		the real-world situtations a computer prgram models and the ways they
		interact than a text-based interface could.

		Rigorously defining requirements for an efficient graphical user
		interface is outside the scope of this report. Instead, we will focus
		on one particular aspect: Responsiveness. Users perceive the response
		of a computer as \enquote{instantaneous} if the response time is less
		than 100 milliseconds \cite{miller1968response}. Ensuring that as
		little of that time as possible is used for drawing the application on
		the screen is key to the usability of a graphical user interface.

		\subsection{How to read this document}
			The Windows operating system has seen many revisions over its
			decades-long lifespan, and many of the features described in this
			report differ significantly from version to version. At the same
			time, documentation of the architecture of the Windows GUI is
			scarce at best.  For this reason, it is not possible to present an
			entirely consistent exposition of the Windows GUI architecture of
			some fixed Windows version.  Instead, different sections of this
			report may be based on different versions of Windows. In order to
			aid the reader in keeping track of which version of Windows is
			being examined at any given point in time, sections and sometimes
			single paragraphs and sentences will be marked with the Windows
			versions they describe. Here is an example:

			\vspace{1em}
			GDI is not hardware-accelerated.\winver{V}
			\vspace{1em}

			Table~\ref{tbl:abbrev} lists all abbreviations used in this document
			and the Windows versions they refer to.

			\begin{table}[h]
				\centering
				\begin{tabular}{r|l}
					Abbreviation & Windows Version \\
					\hline
					\bs{NT4} & Windows NT 4.0 \\
					\bs{V} & Windows Vista (\enquote{Longhorn}) \\
					\bs{7} & Windows 7 \\
					\\
					\bs{ROS} & ReactOS source code
				\end{tabular}
				\caption{Abbreviations for Windows versions used in
					this document}
				\label{tbl:abbrev}
			\end{table}

			In some cases, no documentation of a particular implementation detail
			may exist for any Windows version. In this situation, the author of
			this report used the source code of the ReactOS project in order to
			at least present \emph{a} implementation, without intending to imply
			that this implementation is similar to that of any real Windows version.

	\section{Win32 GUI applications}
		This section gives a broad overview over Windows GUI applications from an
		application developer's point of view. It will serve as a starting point
		for the deeper investigation of implementation details in the following
		sections.

		\subsection{Window classes and objects}
			The fundamental building block of a Windows GUI application is the
			\textit{Window object}, typically just referred to as \textit{window}.
			Window objects are not only windows in the colloquial sense, but also
			most types of controls found inside application windows, such as buttons
			or text boxes. Windows are organized in a hierarchical structure.
			Top-level windows do not have a parent window and are referred to as
			\textit{application windows}. Every window has zero or more child
			windows. Application windows consist of two parts: The \textit{non-client
			area} consists of the frame of the window, including the title bar and
			controls like the close button. It is drawn by the operating system.
			The \textit{client area} is the part of the window that is drawn by
			the application itself.
			\cite{whatiswindow}

			Each window object is an instance of a given \textit{Window class}.
			Window classes, while conceptually comparable, are not classes in
			the object-oriented programming sense. Instead, windows classes are
			registered to the kernel at runtime and can then be instantiated.
			Window classes determine the appearance and behavior of a Window.
			Instances of a window class are created using the function
			\texttt{CreateWindowEx}, which takes the name of the window class
			to instantiate and returns a handle to the newly created window.
			The type of the handle is \texttt{HWND}. This type is opaque to the
			application developer. Functions that in some way operate on a
			window object take the \texttt{HWND} as a parameter.
			\cite{creatingwindow,whatiswindow}

		\subsection{Window messages and procedures} % Todo: Citations!
			Window classes determine the behavior of window objects. The mechanism
			through which window object behavior is defined is the reaction of
			a window object to messages sent to the object. The callback that
			is called when a window object receives a window message is called
			\textit{Window procedure} and is part of the window class, i.e., when
			registering a window class, a pointer to the window procedure for the
			window class is part of the data of the window class. The window
			procedure takes four parameters: The \texttt{HWND} for the window
			object that received the window message, a numeric code giving the
			type of the message received, and two parameters for the message.
			\cite{aboutwinproc}

			Inside the window procedure, messages may or may not be handled, depending
			on their type. Typical types of messages are requests to repaint some
			region of the window, notifications about user input, or the notification
			that the application is about to exit. If a message was not handled
			by the window procedure, a call to \texttt{DefWindowProc} must be
			made, resulting in execution of a default window procedure to
			ensure that all messages are handled. \cite{aboutwinproc}

			In order to support this message-driven mode of operation, the main
			thread of every Windows GUI application is required to execute a
			message loop immediately after creating the main application
			window\footnote{In particular, creation of components on the main
			window is performed in the message handler for the
			\texttt{WM\_CREATE} message, so the main application window will
			not display any controls or content before the main thread enters
			the message loop.}. Applications may fetch the next message in the
			queue using \texttt{GetMessage}. The application then has to pass
			the message first to \texttt{TranslateMessage} and then to
			\texttt{DispatchMessage}. \texttt{TranslateMessage} translates key
			code messages returned by the keyboard driver into Unicode
			characters according to the current keyboard layout and posts new
			messages with these characters to the application. This is a step performed
			by the application itself instead of the operating system because
			there are some cases where an application wants to process the virtual
			key codes instead of the mapped ones \cite{translatemessage} and because the current keyboard
			layout depends on the current thread, so the kernel thread generating
			the messages is by itself unable to map virtual key codes to actual
			key codes\winver{ROS}. \texttt{DispatchMessage} then invokes the window procedure
			of the window object the message was posted to. The target \texttt{HWND}
			is part of the message record fetched by \texttt{GetMessage}. \cite{messages}


	\section{NT Kernel support for GUI applications}\label{sec:win32k}
		\begin{figure*}
			\centering
			\begin{tikzpicture}[yscale=0.7, xscale=1.3]
				\node at (0, 0) {};
				\node at (12, 10.5) {};
				\draw[thick] (0, 5) -- (12, 5);
				\node[anchor=south east] at (12, 5) { \small User };
				\node[anchor=north east] at (12, 5) { \small Kernel };
				\draw (0, 9.5) rectangle node (apps) { Applications } ++(10.5, 1);
				\draw (0, 5.5) rectangle node { user32 } ++(1.5, 1);
				\draw (0.75, 6.5) -- ++(0, 3);
				\draw (0, 3.5) rectangle node { \texttt{win32k.sys} } ++(7.5, 1);
				\draw (0.75, 4.5) -- ++(0, 1);
				\draw (0, -1) rectangle node[align=center,text width=2.5cm] { Kernel-mode I/O Manager } ++(3, 3.5);
				\draw[dashed,color=black!60] (0, 3) -- (3.25, 3) -- (3.25, 1.75) --
					(12, 1.75);
				\draw (1.5, 2.5) -- ++(0, 1);
				\draw (1.75, 5.5) rectangle node (gdi32) { gdi32 } ++(1.5, 1);
				\draw (2.5, 6.5) -- ++(0, 3);
				\draw (2.5, 4.5) -- ++(0, 1);
				\draw (0.2, 3.7) rectangle node { GDI } ++(1, 0.6);
				\draw (3.5, -1) rectangle node { Kernel-mode Display Driver } ++(7, 1);
				\draw (3.5, 2.25) rectangle node { Canonical Display Driver } ++(4, 1);
				\draw (3.5, 0.25) rectangle node { DirectX Kernel Subsystem } ++(7, 1);
				\draw (7, 0) -- ++(0, 0.25);
				\draw (9.25, 1.25) -- ++(0, 4.25);
				\draw (5.5, 3.25) -- ++(0, 0.25);
				\draw (5.5, 1.25) -- ++(0, 1);
				\draw (3.75, 5.5) rectangle node { DirectX } ++(2, 1);
				\draw (3.75, 6.75) rectangle node { milcore } ++(2, 1);
				\draw (6, 5.5) rectangle node { User-mode D3D Driver } ++(4.5, 1);
				\draw (3.75, 8) rectangle node { Avalon } ++(2, 1);
				\draw (3.75, 6) -| ++(-0.25, 3.5);
				\draw (4.75, 9) -- ++(0, 0.5);
				\draw (4.75, 7.75) -- ++(0, 0.25);
				\draw (4.75, 6.5) -- ++(0, 0.25);
				\draw (5.75, 6) -- ++(0.25, 0);
				\draw (6, 8) rectangle node { DWM } ++(2, 1);
				\draw (7, 9) -- ++(0, 0.5);
				\draw (5.75, 7.25) -| ++(1.25, 0.75);
			\end{tikzpicture}
			\caption{An overview of the Windows GUI architecture, showing both user-mode
				and kernel-mode components involved in rendering the Windows GUI. The
				diagram assumes a machine Running Windows Vista using a Vista-ready
				GPU with appropriate drivers.}
			\label{fig:arch}
		\end{figure*}

		The functions available to the user for creating GUI applications are
		exported by \texttt{user32.dll}, which is a user-space library.
		However, the actual functionality is provided by a kernel module called
		\texttt{win32k}. Refer to Figure~\ref{fig:arch} for an overview over the
		components involved in the Windows Graphical User Interface. \cite{probertwin32k}

		\texttt{win32k} maintains a list of all active GUI threads of the
		current session. A GUI thread is somewhat circularly defined as a
		thread that is known to \texttt{win32k} as a GUI thread. When created,
		a thread is not a GUI thread. A thread is promoted to a GUI thread when
		it first calls into \texttt{win32k}, for example when calling
		\texttt{CreateWindowEx} from \texttt{user32.dll}. After a thread is
		promoted, \texttt{win32k} becomes aware of the thread (and in
		particular, is notified of its destruction). In addition, the thread
		receives a bigger kernel stack, because \texttt{win32k} call chains
		can become rather deep and some specific mechanisms employed by \texttt{win32k}
		require extra stack space.
		\cite{probertwin32k,mandy2011kernel}

		Besides managing GUI threads, \texttt{win32k} contains the kernel portion
		of window management. It responds to requests to create and close windows
		and keeps a list of all top-level windows of the window station.
		\cite{probertwin32k,goingdeep}

		Another major responsibility of \texttt{win32k} is the \textit{Raw Input
		Thread} (RIT). The RIT is responsible for receiving user input and posting
		messages to the correct window\footnote{Implementation details of the
		RIT appear to be undocumented. The ReactOS implementation of
		the Raw Input Thread continuously and actively polls mouse and keyboard
		in turn. If the driver returns a new input, the recipient top-level HWND
		is determined. In case of keyboard input or a mouse event while the mouse
		has been captured by an application, the active or capturing application
		receives the message, respectively. In case of a mouse event while the
		mouse is not caputured, all top-level windows are enumerated and the
		window the mouse is above is selected.\winver{ROS}}.
		\cite{probertwin32k}

		\winsubsection{Moving \texttt{win32k} to the kernel}{NT4}
			It is possible to provide the functionality described in Section~\ref{sec:win32k}
			using a user space module. Even further, proper microkernel design principles
			mandate that \texttt{win32k} \emph{must} be placed in user space, because
			it is not inherently reliant on kernel mode functionality.
			In fact, Windows versions prior to Windows NT 4.0
			did implement \texttt{win32k} functionality in user space. However,
			in Windows NT 4.0 \texttt{win32k} was moved to kernel space for
			performance reasons. Windows NT 3.51 contains large number of optimizations
			to be able to support a user-space \texttt{win32k}, many of them related
			to efficient execution of GDI operations (cf. Section~\ref{sec:gdi}).
			For example, GDI operations requested by the applications are not
			actually drawn immediately by calling into the kernel and communicating
			with the graphics hardware. Instead, GDI operations are placed in a
			queue. Once the queue is full or is flushed manually by the application,
			the switch into kernel mode is made and all queued operations are executed
			in sequence. Symetrically, \texttt{win32k} data which is available to the application
			is cached in user space.
			Many (though not all) of these optimizations become unnecessary when
			\texttt{win32k} is moved into kernel space, achieving a simpler implementation
			with improved performance.
			\cite{gdikernel}

			The architectural justification for this change is that the subsystem
			retains its microkernel-like interface while providing significantly
			improved performance. This style of kernel architecture is referred
			to as \emph{modified microkernel}. \cite{gdikernel}

			Moving \texttt{win32k} from user mode to kernel mode without fundamentally
			adapting its architecture---which would be very challending due to
			compatibility---has created an entire class of security problems.
			In several situations arising in the context of \texttt{win32k},
			calling back from the kernel into user mode code (rather than just
			returning) is necessary. In order to facilitate this, \texttt{win32k}
			provides a mechanism called \textit{user-mode callbacks}. This
			functionality has shown to be very prone to creating security problems,
			such as information leakage or transitioning back into user mode after
			a different code execution vulnerability has already been exploited.
			\cite{mandy2011kernel}

	\section{Win32 drawing APIs}
		After registering a window, an application has to draw its client area
		to the screen. Windows provides multiple APIs to accomplish this task.

		\winsubsection{Graphics Device Interface}{V} \label{sec:gdi}
			\textit{Graphics Device Interface} (GDI) is the oldest drawing API
			that is available in modern Windows versions. Unlike its more
			modern cousins, it predates modern 3D acceleration units and as such
			was not designed for GPU hardware acceleration. Instead, it was
			designed to operate using the CPU and supports its own driver model
			for hardware acceleration called \textit{GDI Device Driver
			Interface} (DDI) specifically for accelerating GDI
			primitives. When the DDI was created, hardware that is able to
			accelerate the specific operations used in GDI existed, but modern GPUs operate
			very differently and cannot provide hardware acceleration. As such,
			GDI operations always run on the CPU on Windows Vista. \cite{d2dvsgdi}

			GDI functions are provided by the user space module
			\texttt{gdi32.dll} which in turn calls into the GDI kernel residing
			in \texttt{win32k.sys}. The GDI kernel communicates with the
			system's DDI driver. Windows Vista only supports a single DDI driver,
			the \textit{Canonical Display Driver}, which renders requested operations
			into a buffer located in main memory. Refer to Figure~\ref{fig:arch}
			for an overview. \cite{d2dvsgdi, dwmredirect}

		\subsection{DirectX}
			Microsoft DirectX is a collection of APIs exposing functionality of
			a GPU to application developers. While originally intended for
			multimedia applications such as video playback and video games, it
			is now also used for regular GUI applications and multiple specific
			APIs have been added to the collection over the years to further
			facilitate this use case, with the intention to replace GDI.
			Unlike GDI applications, DirectX applications
			are rendered by the GPU into video memory. \cite{d2dvsgdi,aboutd2d}

			In the context of graphics programming, the most fundamental part of
			DirectX is Direct3D, which provides support for 3D graphics. The
			APIs tailored towards traditional GUI developers, Direct2D and
			DirectWrite, are implemented on top of Direct3D. \cite{aboutd2d}

		\winsubsection{Avalon}{V}\label{sec:milcore}
			Unlike GDI and DirectX, Avalon, also known as Windows Presentation
			Foundation (WPF),
			is not a low level drawing framework
			that communicates directly with a graphics driver, but a
			high level GUI framework available to CLR\footnote{The \textit{Common
			Language Runtime} (CLR) is a runtime system comparable to the Java Virtual
			Machine. It runs \textit{Common Intermediate Language} (CIL) bytecode.
			The most well-known programming language targeting the CLR is Microsoft
			C\#.} applications. Avalon is
			implemented on top of DirectX. The major rendering work is performed
			by a native module called \texttt{milcore.dll} (where MIL is short for
			\textit{Media Integration Layer}). Avalon applications maintain a
			so-called \textit{visual tree} on their UI thread\footnote{An
			earlier implementation using a rental threaded model where every
			application thread was allowed to modify UI elements was scrapped
			for interoperability reasons \cite{goingdeep}.} which represents the
			client area of the application. An unmanaged portion of the UI thread
			code then communicates the visual tree to a \texttt{milcore}-provided
			rendering thread which keeps its own copy of the tree. In some situations,
			raw image data is shared between UI thread and rendering thread. The
			rendering thread then walks the visual tree and issues the correct
			DirectX commands to draw the application.
			\cite{goingdeep,dwmwpf}

			Decoupling the UI thread from the rendering thread comes with several
			advantages. Not having to wait for rendering to finish before being
			able to make changes to the UI can improve application performance.
			Conversely, being able to render despite a busy UI thread will improve
			application responsiveness as perceived by the user. Additionally,
			separating the two tasks allows for \textit{remoting}, i.e., running
			an application and its UI thread on a server and displaying it
			via a rendering thread running on a client. Since both client and
			server maintain the visual tree, changes in the user interface can
			efficiently be communicated to the client using deltas to the visual
			tree.
			\cite{goingdeep}

			When the rendering thread is notified of a change to the visual tree,
			it updates the application on the screen. This step is performed by
			traversing the visual tree and drawing each component of the tree.
			However, if rendering occurrs in response to a change to the visual
			tree, not the entire visual tree is redrawn. Instead, \texttt{milcore}
			employs dirty region management and occlusion culling---i.e.,
			determining which parts of a window are visible at a particular
			moment. These optimizations ensure that no unnecessary rendering takes
			place.
			\cite{goingdeep}

		\subsection{Cross-platform graphics APIs}
			Besides the essentially Windows-specific DirectX API, there are several
			cross-platform APIs that aim to fill a similar niche\footnote{It
			should be noted that DirectX does not fill a single niche. In particular,
			different versions of the DirectX API emphasize different usage models.
			DirectX version 11 and before are most comparable to OpenGL in being
			relatively high-level. In contrast, DirectX 12 is more low-level and
			thus similar to Vulkan.}. Of these, two are available on Windows: OpenGL
			and Vulkan. Since, unlike DirectX, these APIs are not as tightly integrated
			into the Windows operating system, the most interesting question is
			how the interface between the Win32 API and the cross platform API
			is implemented, i.e., how the application programmer can obtain an
			API-specific surface for the client area of a \texttt{HWND}.

			OpenGL is officially supported by Windows. Drivers for OpenGL are
			loaded through a mechanism called \textit{installable client
			drivers} (ICD). Microsoft provides a module called
			\texttt{opengl32.dll} which will then check a specific registry key
			for a vendor-provided OpenGL driver. If such a driver is found,
			OpenGL calls will be relayed to this driver. Otherwise, a
			default implementation provided by Microsoft will be used. Regardless
			of which OpenGL implementation is used, Windows OpenGL applications first obtain
			a GDI device context via \texttt{getDC(HWND)} and then pass this device
			context to the Microsoft-provided function \texttt{wglCreateContext}
			to obtain an OpenGL rendering context for use in the cross-platform portion
			of the application. \cite{oglrc,oglicd}

			Support for graphics software written against the Vulkan API is not
			directly built into Windows as in the OpenGL case. Instead,
			Khronos, the working group that authored the Vulkan specification,
			provide a loader that searches for Vulkan-compatible display
			drivers using an installable client driver model similar to that of
			OpenGL \cite{vulkanloader}. Vulkan specifies a Windows-specific
			extension to create a Vulkan surface that corresponds to the client
			area of a \texttt{HWND}: \texttt{vkCreateWin32SurfaceKHR}. Once
			this surface has been created, the rest of the code of a Vulkan
			application is platform-agnostic \cite{vulkanspec}.

	\section{Window Management}
		\subsection{Window managers and compositing}
			The window manager is the component of a window-based graphical user
			interface that is responsible for managing the position of each active
			window on the desktop and making sure the desktop as the sum of its
			parts is assembled correctly. There are two general approaches to this
			task: \emph{compositing} and \emph{non-compositing} window management.

			A non-compositing window manager draws non-window elements of the
			desktop (such as the taskbar or equivalent) and maintains the
			position and relative order of all currently visible Windows. It
			then instructs applications to draw the currently visible portion
			of their windows directly onto the screen buffer. In particular,
			this means that all applications draw to the same memory buffer and
			when a window is moved on top of another window, that window's data
			will be overwritten.

			Non-compositing window managers are efficient and relatively
			straightforward to implement. However, there are several drawbacks
			to this approach.  One such drawback is that it inherently comes
			with several visual artifacts. Because window contents are drawn
			directly on the screen without any form of dubble buffering, screen
			tearing will be visible during high-motion events such as scrolling
			text. Additionally, in a situation where a window is moved on top
			of an unresponsive window and subsequently moved away, requests to
			redraw the region of the bottom window which is now visible again
			will be sent, but not handled because the application is not
			responsive. The result is the well-known \enquote{trail} effect
			observed in old versions of Microsoft Windows. Refer to
			Figure~\ref{fig:trail} for an example of the problem.
			\begin{figure}[h]
				\centering
				\includegraphics[width=0.8\columnwidth]{trail}
				\caption{The \enquote{trail} effect observed on pre-Vista versions
					of Windows. An application is moved on top of another application
					and then moved away. When the top window is moved away, the bottom
					application needs to redraw the uncovered region. If it does not
					respond to the repaint message, the moved portions of the top
					window are not erased.}
				\label{fig:trail}
			\end{figure}

			Another shortcoming of non-compositing window managers is their
			inability to provide visual effects. As a consequence of the fact
			that (at most) one application determines the color of each individual
			pixel on the screen, effects such as partially transparent windows
			cannot be realized with non-compositing window managers. Additionally,
			because a window may only be at most at one position of the screen,
			and that position has to be the Window's \enquote{actual} position,
			no thumbnails or overviews of windows can be shown.

			Compositing is an attempt at a solution to the aforementioned
			problems.  If a compositing window manager is in use, applications
			do not draw directly to the screen. Instead, each applications has
			its own off-screen buffer. The
			window manager then assembles the final
			desktop from the content of these buffers. It is immediately clear how this approach addresses the
			problems of non-compositing window-managers described above: It is
			easy to perform double buffering and even when a window is not
			responding, the window manager knows its last good state and can
			use it to prevent trails. Furthermore, visual effects are trivial
			to achieve when compositing is used. \cite{dwmoverview}

		\winsubsection{The Desktop Window Manager}{V}\label{sec:dwm}
			The \emph{Desktop Window Manager} (DWM) is the compositing window
			manager used by Windows and introduced in Longhorn
			\cite{dwmoverview}.  It is implemented as a full-screen Direct3D
			user-space application. In particular, DWM rendering is
			hardware-accelerated. When DWM is active, applications render into
			off-screen DirectX buffers which are mapped onto flat surfaces in
			3D space and rendered by the graphics hardware. This design enables
			three-dimensionally transforming the windows, which is used for the
			\enquote{Flip3D} feature of Windows Vista invoked by the keyboard
			shortcut \keys{Win+\tab} and its more modest counterparts in more
			recent versions of Microsoft Windows. Visual effects such as
			transparency are implemented using DirectX pixel shaders. In addition,
			double buffering using a buffer flipping mechanism is implemented.
			\cite{dwmdirectx}

			Even though DWM is a native application, its implementation closely
			resembles that of an Avalon application. In particular, the desktop
			is modeled as a visual tree in the same way that WPF applications
			are modeled as a visual tree (refer to Section~\ref{sec:milcore}
			for details) and also uses \texttt{milcore.dll} to render the
			visual tree through DirectX. This code reuse provides a
			substantial number of necessary functional and performance
			features essentially for free.  In particular, the visual tree
			model, which at first might appear not to fit a mostly
			non-hierarchical situation, such as the desktop, very well,
			turns out to be very beneficial, since the Avalon composition
			engine comes with support for \emph{occlusion culling}---i.e.,
			determining which parts of a window are visible at a particular
			moment. This feature completely takes care of the task to
			determine which parts of a window should be drawn. Similarly, the
			entire logic that decides when to request which region of which window
			to redraw (scheduling and dirty region management) is taken from
			Avalon.
			\cite{dwmwpf}

			The visual \enquote{tree} as employed by DWM allows for non-tree edges
			in order to render windows at locations different from their \enquote{actual}
			position. This feature is used to implement thumbnails and previews.
			Another use of this feature is the \enquote{magnifier} accessibility
			feature, which renders a portion of a screen in a larger region.
			It is implemented by additionally applying a transform to the entire
			subtree that the virtual edge points to in order to render into a
			magnified buffer\footnote{In addition, special care is taken by the
			application
			that this virtual edge is not traversed once again, which would result
			in an unwanted instance of the Droste effect.}.
			For most applications, this means that the pixels are naïvely scaled
			up. However, Avalon applications come with special support for magnification,
			resulting in a pixel-perfect magnified presentation. This support
			is enabled by specific handling in Avalon---in particular, the DWM's
			visual tree does \emph{not} have access to the visual tree of an
			Avalon application.
			\cite{goingdeep}

			The way in which windows are redirected when DWM is in use depends
			on the drawing API used by the application. GUI applications which
			(directly or indirectly)
			use DirectX for rendering can render into a single buffer located
			in video memory allocated
			by the DWM. Because DWM itself uses DirectX, DirectX applications
			natively render into the format used by DWM, so the DWM can use
			these buffers directly to perform composition. Sharing a single buffer
			between an application and DWM is not natively supported by DirectX
			but a WDDM feature; refer to Section~\ref{sec:wddm} for details.
			\cite{dwmredirect}

			Applications employing GDI for their rendering cannot render into
			the DirectX pixel format, but render into a DWM-provided main memory
			buffer in their native GDI format. When the window is created, DWM
			automatically also creates a DirectX buffer in video memory. The
			application draws into the GDI buffer, and DWM manually transcribes
			the GDI buffer to the DirectX buffer when necessary and uses the result
			for composition.
			\cite{dwmredirect}

		\winsubsection{The Windows Display Driver Mo\-del}{V}\label{sec:wddm}
			The implementation of DWM described in Section~\ref{sec:dwm}
			fundamentally relies on graphics driver support in order to achieve
			reasonable performance.  Prior to Longhorn, DirectX applications
			assumed that they have exclusive access to the GPU. In particular,
			there was no virtual memory and no support for preemption. This is
			unproblematic as long as there is at most one active DirectX application
			and that application has reasonably predictable video memory requirements.
			However, the Desktop Window Manager \emph{is} a DirectX appliction that
			by design both runs alongside other DirectX applications and whose
			memory consumption is dependent on the number of open windows and therefore
			very unpredictable.
			In order to address these problems, display drivers targeting Longhorn
			have to be written against the Windows Display Driver Model. This
			display driver framework introduces the cooperative multitasking
			features known from regular applications running on the CPU to the
			GPU. \cite{dwmwddm}

			One of these features is an implementation of preemption called
			WDDM \emph{scheduling}. The granularity of preemtion depends on
			the version of DirectX that is used and hardware support. When
			using \emph{Basic Scheduling}, available from DirectX 9 without
			special hardware support, primitives and shaders cannot be interrupted,
			so preemption can only take place inbetween these basic operations.
			If the hardware supports it and DirectX 10 is in use, \emph{Advanced
			Scheduling} is available, allowing preemption to take place in the mid
			of primities or shaders. \cite{dwmwddm}

			The other large feature required for cooperative multitasking is
			virtual memory. As GPUs may have several regions of video memory
			specialized for certain tasks, the address space of a GPU may
			be nonlinear. For this reason, the GPU announces some number of
			available segments of video memory to the driver framework \cite{gpuseg}.
			When using the WDDM 1.$x$ model for virtual graphics
			memory, applications work with segment physical addresses. In the event
			that a piece of memory is moved or paged out, addresses in the command
			buffer are patched. This model was updated to using proper virtual
			addresses with WDDM 2.0, introduced in Windows 10. \cite{wddm2}

			Finally, a third feature that is necessary to implement the redirection
			mechanism for DirectX applications described in Section~\ref{sec:dwm}
			is DirectX surface sharing, which gives an application and the DWM
			access to the same DirectX surface buffer, so that the DWM can use the
			same surface for compositing that is used by the application for
			drawing to. \cite{dwmredirect}

			The desktop window manager cannot run without a WDDM-compliant
			display driver \cite{dwmwddm}. If no such driver is available, one
			of two things will happen, depending on the version of Windows that
			is running. Under Windows Vista and Windows 7, DWM will be
			disabled\footnote{In Windows Vista/7, there are some other ways for
			DWM to be disabled. Applications can disable the DWM manually (for
			example immediately before switching to full-screen mode)
			\cite{disabledwm}, or DWM can be automatically disabled by an
			application using the drawing APIs incorrectly \cite{dwmredirect}.}
			and the non-compositing window manager\footnote{Contrary to the DWM,
			the non-compositing window manager referred to as \textit{USER} resides
			in \texttt{win32k} and thus in kernel space \cite{probertwin32k}.}
			from Windows XP will be used. When running Windows 8 or later,
			the DWM will be run, but a software-based renderer called
			\textit{Microsoft Basic Display Adapter} will serve as a replacement
			for the display driver \cite{dwmalwayson}.

			From a GPU driver developer's point of view, a WDDM driver consists
			of a \textit{user-mode display driver} (also referred to as
			\textit{user-mode Direct3D driver}) and a kernel mode
			\textit{display miniport driver}, sometimes called kernel-mode
			display driver. Both components are solely concerned with handling
			DirectX operations---calls to all other types of graphics API that
			are available on Windows, notably including OpenGL in case the driver
			vendor chooses not to provide direct implementation of OpenGL via
			an installable client driver, are either not
			hardware-accelerated or relayed to the appropriate DirectX commands.
			Figure~\ref{fig:arch} visualizes the interaction of a WDDM driver with
			other GUI-related components.
			\cite{wddmarch,d2dvsgdi}

		\winsubsection{Hardware-accelerated GDI ren\-der\-ing}{7}
			During Longhorn development, having GDI directly render to DirectX
			surfaces in video memory was deemed infeasible; not because GDI calls
			could not be adapted to work with the DirectX buffer format, but because
			GDI renders using the CPU and many GDI operations not only write to
			the buffer, but also need to read from it, but reading from video memory
			using the CPU is a very slow operation \cite{dwmredirect}. However,
			Windows 7 does eliminate the main memory buffer for GDI. The performance
			issues were resolved by providing explicit hardware acceleration for
			the offending GDI operations in WDDM version 1.1. In particular,
			starting with Windows 7, the
			main memory comsumption of the Desktop Window Manager is independent
			of the number of open windows (however, VRAM comsumption still scales
			linearly with the number of open windows).
			\cite{win7}

	\onecolumn{\printbibliography}
\end{document}
